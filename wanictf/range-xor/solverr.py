from z3 import *

N = 10
A = [532, 746, 606, 601, 293, 825, 912, 826, 789, 190]
MOD = int(1e9) + 7


# Define variables
B = [BitVec('b{}'.format(i), 32) for i in range(N)]

# Define constraints
constraints = []
for i in range(N):
    constraints.append(B[i] >= 0)
    constraints.append(B[i] <= 1000)

while True:
    # Compute minimum value of f
    min_f = [min(A[i], 1000 - A[i]) for i in range(N)]

    # Define new constraints
    new_constraints = []
    for i in range(N):
        new_constraints.append(Or(B[i] == A[i], B[i] == 1000 - A[i]))

    # Check if constraints have changed
    if constraints == new_constraints:
        break

    constraints = new_constraints

# Compute XOR of B
X = B[0]
for i in range(1, N):
    X = X ^ B[i]

# Define solver
solver = Solver()
solver.add(constraints)

# Count number of solutions that minimize X
count = 0
while solver.check() == sat:
    model = solver.model()
    if model.eval(X).as_signed_long() == 32:
        count += 1
    block = []
    for i in range(N):
        block.append(B[i] != model[B[i]])
    solver.add(Or(block))

# Print result
flag = pow(2, count, MOD)
print('FLAG{{{}}}'.format(flag))
